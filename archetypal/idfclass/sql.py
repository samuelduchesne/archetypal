"""sql module."""

from datetime import timedelta
from sqlite3 import connect
from typing import Union, Optional

import pandas as pd
from energy_pandas import EnergyDataFrame
from pandas import to_datetime


def collect_output_by_name(
    sql_file: str,
    variable_or_meter: Union[str, list],
    reporting_frequency: Optional[str] = "Monthly",
) -> EnergyDataFrame:
    """Get an EnergyDataFrame for a specified meter or variable.

    Args:
        sql_file (str): Full path to an SQLite file that was generated by EnergyPlus.
        variable_or_meter (str or list): The name of an EnergyPlus output meter or
            variable to be retrieved from the SQLite result file. This can also be an
            array of output names for which all data collections should be retrieved.
        reporting_frequency (str):

    Returns:
        EnergyDataFrame: An EnergyDataFrame with the variable_or_meter as columns.
    """
    with connect(sql_file) as conn:
        cols = "ReportDataDictionaryIndex, IndexGroup, KeyValue, Name, Units, ReportingFrequency"
        if isinstance(variable_or_meter, str):  # assume it's a single output
            query = f"""
                    SELECT {cols} 
                    FROM ReportDataDictionary 
                    WHERE Name=@output_name 
                    AND ReportingFrequency=@reporting_frequency;
                    """
            header_rows = pd.read_sql(
                query,
                conn,
                params={
                    "output_name": variable_or_meter,
                    "reporting_frequency": reporting_frequency,
                },
            )
        elif len(variable_or_meter) == 1:  # assume it's a list
            query = f"""
                    SELECT {cols} 
                    FROM ReportDataDictionary 
                    WHERE Name=@output_name 
                    AND ReportingFrequency=@reporting_frequency;
                    """
            header_rows = pd.read_sql(
                query,
                conn,
                params={
                    "output_name": variable_or_meter[0],
                    "reporting_frequency": reporting_frequency,
                },
            )
        else:  # assume it is a list of outputs
            query = f"""
                    SELECT {cols} 
                    FROM ReportDataDictionary 
                    WHERE Name IN {tuple(variable_or_meter)}
                    AND ReportingFrequency=@reporting_frequency;"""
            header_rows = pd.read_sql(
                query,
                conn,
                params={
                    "reporting_frequency": reporting_frequency,
                },
            )
        # if nothing was found, return an empty DataFrame
        if len(header_rows) == 0:
            return EnergyDataFrame([])
        else:
            header_rows.set_index("ReportDataDictionaryIndex", inplace=True)

        # extract all data of the relevant type from ReportData
        rel_indices = tuple(header_rows.index.to_list())
        if len(rel_indices) == 1:
            data = pd.read_sql(
                """SELECT rd.Value,
                          rd.ReportDataDictionaryIndex, 
                          t.Month,
                          t.Day,
                          t.Hour,
                          t.Minute,
                          t.Interval
                FROM ReportData as rd 
                        LEFT JOIN Time As t ON rd.TimeIndex = t.TimeIndex 
                WHERE ReportDataDictionaryIndex=? ORDER BY t.TimeIndex 
                AND (IFNULL(t.WarmupFlag, 0) = @warmup_flag);""",
                conn,
                params=[rel_indices[0], 0],
            )
        else:
            data = pd.read_sql(
                f"""SELECT rd.Value,
                          rd.ReportDataDictionaryIndex,
                          t.Month,
                          t.Day,
                          t.Hour,
                          t.Minute,
                          t.Interval
                FROM ReportData as rd
                        LEFT JOIN Time As t ON rd.TimeIndex = t.TimeIndex
                WHERE ReportDataDictionaryIndex IN {tuple(rel_indices)}
                AND (IFNULL(t.WarmupFlag, 0) = @warmup_flag)
                ORDER BY rd.ReportDataDictionaryIndex, t.TimeIndex;""",
                conn,
                params={"warmup_flag": 0},
            )

        # Pivot the data so that ReportDataDictionaryIndex becomes the column index.
        data = data.pivot(
            index=["Month", "Day", "Hour", "Minute", "Interval"],
            columns=["ReportDataDictionaryIndex"],
            values="Value",
        )

        # Rename the columns ReportDataDictionaryIndex with the header_rows Name.
        # From a number to a human-readable name
        data.rename(header_rows["Name"].to_dict(), axis=1, inplace=True)

        # reset the index to prepare the DatetimeIndex
        date_time_names = data.index.names
        data.reset_index(inplace=True)
        index = to_datetime(
            {
                "year": 2018,
                "month": data.Month,
                "day": data.Day,
                "hour": data.Hour,
                "minute": data.Minute,
            }
        )
        # Adjust timeindex by timedelta
        index -= data["Interval"].apply(lambda x: timedelta(minutes=x))
        index = pd.DatetimeIndex(index, freq="infer")
        # get data
        data = data.drop(columns=date_time_names)
        data.index = index

        # Create the EnergyDataFrame and set the units using dict
        data = EnergyDataFrame(data)
        data.units = header_rows.set_index("Name")["Units"].to_dict()

    return data
